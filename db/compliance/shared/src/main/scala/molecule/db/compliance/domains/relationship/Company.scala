package molecule.db.compliance.domains.relationship

import molecule.DomainStructure


object Company extends DomainStructure {

  trait Employee {
    val name = oneString
    // .Assignment_.role.Project.budget

    // no
    // .Projects.budget
    // .Projects.*(Project.budget)
  }

  trait Project {
    val name   = oneString
    val budget = oneInt
    // .Assignment_.role.Employee.name

    // no
    // .Employees.name
    // .Employees.*(Employee.name)
  }

  trait Assignment {
    val role = oneString

    val employee = manyToOne[Employee] // implicit reverse ref "Assignments" in Employee
    val project  = manyToOne[Project] //  implicit reverse ref "Assignments" in Project

    //    val employee = one[Employee].Projects
    //    val project  = one[Project].Employees

    //    val employee = one[Employee]("Employees") // or autogenerated plural...
    //    val project  = one[Project]("Projects")

    // Assignment_.employee.project.role.insert(
    //   (1, 7, "Manager"),
    //   (2, 7, "Support"),
    // ).transact
  }
}









//Employee.name.Assignment.role.Project.name
//Employee.name.Projects.name
//Employee.name.Projects.*(Project.name)
//
//Employee.name.Assignment.role.Projects.name
//Employee.name.Projects.name
//Employee.name.Projects.*(Project.name)


////// direct join table query
////Assignments.employee.role.project.insert(
////  (bob, "lead", scala),
////  (bob, "engineer", java),
////  (liz, "manager", scala)
////).transact
//
//// Using the Assignment join table as any other referenced table (no need for `Project_`
//Employee.name.Assignment.role_("lead").Project.name.query.get ==> List(
//  ("Bob", "Scala")
//)
//
//// or `Projects` to query the joined data (transparently using the join table)
//Employee.name.Projects.name.query.get ==> List(
//  ("Bob", "Scala"),
//  ("Bob", "Java"),
//  ("Liz", "Scala")
//)
//
//// or nested without join property access
//Employee.name.Projects.*(Project.name).query.get ==> List(
//  ("Bob", List("Scala", "Java")),
//  ("Liz", List("Scala"))
//)
//
//
//
//
//
////// direct join table query
////Assignments.employee.role.projects.insert(
////  (bob, "lead", scala),
////  (bob, "engineer", java),
////  (liz, "manager", scala)
////).transact
//
//// Using the Assignment join table as any other referenced table (no need for `Project_`
//Employee.name.Assignment.role_("lead").Projects.name.query.get ==> List(
//  ("Bob", "Scala")
//)
//
//// or `Projects` to query the joined data (transparently using the join table)
//Employee.name.Projects.name.query.get ==> List(
//  ("Bob", "Scala"),
//  ("Bob", "Java"),
//  ("Liz", "Scala")
//)
//
//// or nested without join property access
//Employee.name.Projects.*(Project.name).query.get ==> List(
//  ("Bob", List("Scala", "Java")),
//  ("Liz", List("Scala"))
//)